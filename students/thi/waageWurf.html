<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waagerechter Wurf Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Aktualisierte Icon-Bibliothek Quelle -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Benutzerdefinierte Schriftart für bessere Lesbarkeit von Zahlen */
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
        }
        
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 0 2px #1e293b; 
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }

        input[type=range]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3);
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="p-4 border-b border-slate-700 bg-slate-800 flex justify-between items-center shrink-0">
        <div class="flex items-center gap-2">
            <i data-lucide="activity" class="text-blue-400"></i>
            <h1 class="text-xl font-bold bg-gradient-to-r from-blue-400 to-emerald-400 bg-clip-text text-transparent">Physik Labor: Waagerechter Wurf</h1>
        </div>
        <div class="text-xs text-slate-400 hidden sm:block">
            g = 9.81 m/s²
        </div>
    </header>

    <!-- Main Layout -->
    <main class="flex-1 flex flex-col lg:flex-row overflow-hidden">
        
        <!-- Canvas Container -->
        <div class="relative flex-1 bg-slate-950 overflow-hidden flex flex-col" id="canvas-container">
            <canvas id="simCanvas" class="w-full h-full block cursor-crosshair"></canvas>
            
            <!-- Overlay Stats -->
            <div class="absolute top-4 left-4 bg-slate-900/80 backdrop-blur border border-slate-700 p-3 rounded-lg shadow-xl text-sm pointer-events-none select-none">
                <div class="grid grid-cols-2 gap-x-6 gap-y-1">
                    <span class="text-slate-400">Zeit (t):</span>
                    <span class="mono text-yellow-400 font-bold" id="stat-time">0.00 s</span>
                    
                    <span class="text-slate-400">Strecke (x):</span>
                    <span class="mono text-blue-400" id="stat-x">0.00 m</span>
                    
                    <span class="text-slate-400">Höhe (y):</span>
                    <span class="mono text-emerald-400" id="stat-y">0.00 m</span>

                    <span class="text-slate-400">Geschw. (v):</span>
                    <span class="mono text-purple-400" id="stat-v">0.00 m/s</span>
                </div>
            </div>

            <!-- Legend -->
            <div class="absolute bottom-4 right-4 text-xs text-slate-500 pointer-events-none select-none flex flex-col items-end gap-1">
                <div class="flex items-center gap-2">
                    <span>vx (konstant)</span> <div class="w-4 h-0.5 bg-blue-500"></div>
                </div>
                <div class="flex items-center gap-2">
                    <span>vy (beschleunigt)</span> <div class="w-4 h-0.5 bg-red-500"></div>
                </div>
                <div class="flex items-center gap-2">
                    <span>Flugbahn</span> <div class="w-4 h-0.5 border-t border-dashed border-white opacity-50"></div>
                </div>
            </div>
        </div>

        <!-- Controls Sidebar -->
        <aside class="w-full lg:w-80 bg-slate-900 border-t lg:border-t-0 lg:border-l border-slate-700 p-6 flex flex-col gap-6 overflow-y-auto z-10 shadow-2xl">
            
            <!-- Parameter Controls -->
            <div class="space-y-6">
                <h2 class="text-sm font-semibold text-slate-400 uppercase tracking-wider flex items-center gap-2">
                    <i data-lucide="sliders" class="w-4 h-4"></i> Parameter
                </h2>
                
                <!-- Höhe -->
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label for="height" class="text-sm font-medium">Tischhöhe (h)</label>
                        <span class="mono text-sm text-emerald-400" id="val-height">5.0 m</span>
                    </div>
                    <input type="range" id="height" min="1" max="15" step="0.1" value="5" class="w-full">
                </div>

                <!-- Geschwindigkeit -->
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label for="velocity" class="text-sm font-medium">Startgeschw. (v₀)</label>
                        <span class="mono text-sm text-blue-400" id="val-velocity">4.0 m/s</span>
                    </div>
                    <input type="range" id="velocity" min="1" max="20" step="0.5" value="4" class="w-full">
                </div>

                <!-- Zeitlupe -->
                <div class="flex items-center justify-between pt-2">
                    <label for="slowmo" class="text-sm text-slate-300">Zeitlupe (0.2x)</label>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle" id="slowmo" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer left-0 top-0 transition-all duration-300"/>
                        <label for="slowmo" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-700 cursor-pointer"></label>
                    </div>
                </div>
            </div>

            <!-- Calculated Data (Pre-calc) -->
            <div class="p-4 bg-slate-800/50 rounded-lg border border-slate-700/50 space-y-2">
                <h3 class="text-xs font-semibold text-slate-500 uppercase">Vorhersage</h3>
                <div class="flex justify-between text-sm">
                    <span>Flugdauer:</span>
                    <span class="mono text-slate-200" id="calc-time">-- s</span>
                </div>
                <div class="flex justify-between text-sm">
                    <span>Wurfweite:</span>
                    <span class="mono text-slate-200" id="calc-range">-- m</span>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="mt-auto grid grid-cols-2 gap-3">
                <button id="btn-reset" class="px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-white font-medium transition-colors flex justify-center items-center gap-2">
                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i> Reset
                </button>
                <button id="btn-start" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 text-white font-medium shadow-lg shadow-blue-900/20 transition-all active:scale-95 flex justify-center items-center gap-2">
                    <i data-lucide="play" class="w-4 h-4" id="icon-play"></i> Start
                </button>
            </div>
            
            <div class="text-xs text-slate-500 text-center leading-relaxed">
                <p>Formel Flugbahn:</p>
                <p class="italic font-serif">y(x) = h - ½·g·(x/v₀)²</p>
            </div>

        </aside>

    </main>

    <script>
        // Helper für sicheres Icon-Update
        function updateIcons() {
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons();
            }
        }

        // Icons initialisieren
        updateIcons();

        // Canvas Setup
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // Physics Constants
        const g = 9.81; // Erdbeschleunigung m/s^2
        const PIXELS_PER_METER = 30; // Skalierungsfaktor
        
        // Simulation State
        let state = {
            h: 5.0,     // Höhe in Metern
            v0: 4.0,    // Anfangsgeschwindigkeit in m/s
            t: 0,       // Aktuelle Zeit
            running: false,
            finished: false,
            slowMo: false,
            ballRadius: 0.3 // Meter
        };

        let animationId = null;
        let lastTimestamp = 0;

        // UI Elements
        const ui = {
            height: document.getElementById('height'),
            velocity: document.getElementById('velocity'),
            slowMo: document.getElementById('slowmo'),
            valHeight: document.getElementById('val-height'),
            valVelocity: document.getElementById('val-velocity'),
            statTime: document.getElementById('stat-time'),
            statX: document.getElementById('stat-x'),
            statY: document.getElementById('stat-y'),
            statV: document.getElementById('stat-v'),
            calcTime: document.getElementById('calc-time'),
            calcRange: document.getElementById('calc-range'),
            btnStart: document.getElementById('btn-start'),
            btnReset: document.getElementById('btn-reset'),
            iconPlay: document.getElementById('icon-play')
        };

        // Resize Canvas
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        // --- Physics & Math ---

        function calculatePredictions() {
            // Flugdauer: t = sqrt(2h/g)
            const flightTime = Math.sqrt((2 * state.h) / g);
            // Wurfweite: x = v0 * t
            const range = state.v0 * flightTime;
            
            ui.calcTime.innerText = flightTime.toFixed(2) + " s";
            ui.calcRange.innerText = range.toFixed(2) + " m";
            
            return { flightTime, range };
        }

        function getPositionAtTime(t) {
            // x(t) = v0 * t
            const x = state.v0 * t;
            // y(t) = h - 0.5 * g * t^2
            const y = state.h - 0.5 * g * t * t;
            
            const vx = state.v0;
            const vy = -g * t;
            const v = Math.sqrt(vx*vx + vy*vy);

            return { x, y, vx, vy, v };
        }

        // --- Drawing Helper ---

        // Konvertiert Meter in Canvas-Koordinaten
        // Origin (0,0) in Physik ist unten am Fuß des Tisches (bzw. x=0, y=0 ist der Boden)
        // Im Canvas verschieben wir den Ursprung etwas nach rechts und unten
        function toCanvas(x_meter, y_meter) {
            const marginX = 100; // Abstand von links
            const groundY = canvas.height - 50; // Bodenposition Y im Canvas
            
            return {
                x: marginX + (x_meter * PIXELS_PER_METER),
                y: groundY - (y_meter * PIXELS_PER_METER)
            };
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color) {
            const headlen = 10; // length of head in pixels
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(toX, toY);
            ctx.fill();
        }

        // --- Main Draw Function ---

        function draw() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Ground Level
            const groundY = canvas.height - 50;
            const originX = 100;

            // 1. Draw Environment (Table, Floor)
            ctx.fillStyle = "#1e293b"; // Slate-800
            ctx.fillRect(0, groundY, canvas.width, 50); // Boden
            
            // Grid Lines (Horizontal) every meter
            ctx.strokeStyle = "#334155";
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let m = 0; m < 20; m+=2) {
                const pos = toCanvas(0, m);
                if(pos.y < 0) break;
                ctx.moveTo(0, pos.y);
                ctx.lineTo(canvas.width, pos.y);
            }
            ctx.stroke();

            // Table
            const tableHeightPx = state.h * PIXELS_PER_METER;
            const tableWidthPx = 100; // Fixed visual width
            
            // Tischbein/Körper
            ctx.fillStyle = "#475569";
            ctx.fillRect(0, groundY - tableHeightPx, tableWidthPx, tableHeightPx);
            
            // Tischkante Text
            ctx.fillStyle = "#94a3b8";
            ctx.font = "12px Inter";
            ctx.fillText("h = " + state.h.toFixed(1) + "m", 10, groundY - tableHeightPx / 2);

            // 2. Draw Trajectory Prediction (Dashed Line)
            const preds = calculatePredictions();
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            
            // Zeichne Parabel
            const step = 0.05; // Zeitschritt für Zeichnung
            for(let simT = 0; simT <= preds.flightTime; simT += step) {
                const p = getPositionAtTime(simT);
                const c = toCanvas(p.x, p.y);
                if (simT === 0) ctx.moveTo(c.x, c.y);
                else ctx.lineTo(c.x, c.y);
            }
            // Letzter Punkt (Boden)
            const finalP = getPositionAtTime(preds.flightTime);
            const finalC = toCanvas(finalP.x, 0); // Force y=0 visual
            ctx.lineTo(finalC.x, finalC.y);
            
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            // 3. Draw Ball & Vectors
            const pos = getPositionAtTime(state.t);
            
            // Falls Ball unter Boden wäre, korrigieren für visuelle Darstellung (stoppt am Boden)
            let visualYMeter = pos.y;
            if (visualYMeter < 0) visualYMeter = 0;
            
            const ballCanvasPos = toCanvas(pos.x, visualYMeter);
            const ballRadiusPx = state.ballRadius * PIXELS_PER_METER;

            // Ball Schatten (nur wenn nah am Boden)
            if (visualYMeter < 2) {
                const shadowScale = 1 - (visualYMeter / 2);
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.beginPath();
                ctx.ellipse(ballCanvasPos.x, groundY, ballRadiusPx * shadowScale, ballRadiusPx * 0.3 * shadowScale, 0, 0, Math.PI*2);
                ctx.fill();
            }

            // Ball
            ctx.beginPath();
            ctx.arc(ballCanvasPos.x, ballCanvasPos.y - ballRadiusPx, ballRadiusPx, 0, Math.PI * 2);
            ctx.fillStyle = state.finished ? "#ef4444" : "#fbbf24"; // Rot wenn fertig, Gelb wenn aktiv
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#fff";
            ctx.stroke();

            // Vektoren (nur zeichnen, wenn nicht am Boden liegend oder gerade aufgeschlagen)
            if (pos.y >= -0.1 && state.v0 > 0) {
                const vecScale = 15; // Pixel pro 1 m/s für Vektorlänge
                
                // Vx (Blau)
                drawArrow(ctx, 
                    ballCanvasPos.x, ballCanvasPos.y - ballRadiusPx, 
                    ballCanvasPos.x + (pos.vx * vecScale), ballCanvasPos.y - ballRadiusPx, 
                    "#3b82f6"
                );

                // Vy (Rot) - Vy ist negativ, im Canvas aber positiv nach unten. 
                // pos.vy ist negativ (Physik). toCanvas invertiert Y.
                // Einfacher: Wir rechnen in Pixel-Offsets
                // Physik Vy = -9.81. Im Canvas muss Pfeil nach unten.
                // Wir nehmen den Betrag für die Länge und zeichnen nach unten.
                if (Math.abs(pos.vy) > 0.1) {
                    drawArrow(ctx, 
                        ballCanvasPos.x, ballCanvasPos.y - ballRadiusPx, 
                        ballCanvasPos.x, ballCanvasPos.y - ballRadiusPx + (Math.abs(pos.vy) * vecScale), 
                        "#ef4444"
                    );
                }
            }
        }

        // --- Animation Loop ---

        function update(timestamp) {
            if (!state.running) return;

            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000; // in Sekunden
            lastTimestamp = timestamp;

            // Zeit-Skalierung für Zeitlupe
            const timeScale = state.slowMo ? 0.2 : 1.0;
            
            // Physik Update
            state.t += deltaTime * timeScale;

            // Kollisionserkennung Boden
            const currentPos = getPositionAtTime(state.t);
            if (currentPos.y <= 0) {
                // Exakten Aufschlagzeitpunkt berechnen
                const preds = calculatePredictions();
                state.t = preds.flightTime;
                state.running = false;
                state.finished = true;
                
                // UI Update auf "Fertig" Status
                ui.btnStart.innerHTML = `<i data-lucide="rotate-ccw" class="w-4 h-4"></i>`;
                updateIcons();
            }

            // UI Stats Update
            updateStats();
            draw();

            if (state.running) {
                animationId = requestAnimationFrame(update);
            } else {
                lastTimestamp = 0; // Reset timer logic
            }
        }

        function updateStats() {
            const pos = getPositionAtTime(state.t);
            
            ui.statTime.innerText = state.t.toFixed(2) + " s";
            ui.statX.innerText = pos.x.toFixed(2) + " m";
            // Zeige 0 anstatt negative Werte beim Aufprall
            ui.statY.innerText = Math.max(0, pos.y).toFixed(2) + " m";
            ui.statV.innerText = pos.v.toFixed(2) + " m/s";
        }

        // --- Controls Handling ---

        function updateParams() {
            state.h = parseFloat(ui.height.value);
            state.v0 = parseFloat(ui.velocity.value);
            
            ui.valHeight.innerText = state.h.toFixed(1) + " m";
            ui.valVelocity.innerText = state.v0.toFixed(1) + " m/s";
            
            // Wenn Simulation nicht läuft, Reset Position um Vorschau zu aktualisieren
            if (!state.running && state.t === 0) {
                draw();
                calculatePredictions();
            }
        }

        function toggleSimulation() {
            if (state.finished) {
                resetSimulation();
                return;
            }

            state.running = !state.running;
            
            if (state.running) {
                ui.btnStart.innerHTML = `<i data-lucide="pause" class="w-4 h-4"></i> Pause`;
                ui.btnStart.classList.replace('bg-blue-600', 'bg-amber-600');
                ui.btnStart.classList.replace('hover:bg-blue-500', 'hover:bg-amber-500');
                lastTimestamp = 0; // Wichtig für Delta Time Reset
                animationId = requestAnimationFrame(update);
                
                // Inputs sperren während Lauf
                ui.height.disabled = true;
                ui.velocity.disabled = true;
            } else {
                ui.btnStart.innerHTML = `<i data-lucide="play" class="w-4 h-4"></i> Weiter`;
                ui.btnStart.classList.replace('bg-amber-600', 'bg-blue-600');
                ui.btnStart.classList.replace('hover:bg-amber-500', 'hover:bg-blue-500');
                cancelAnimationFrame(animationId);
            }
            updateIcons();
        }

        function resetSimulation() {
            state.running = false;
            state.finished = false;
            state.t = 0;
            cancelAnimationFrame(animationId);
            
            ui.btnStart.innerHTML = `<i data-lucide="play" class="w-4 h-4"></i> Start`;
            ui.btnStart.classList.remove('bg-amber-600', 'hover:bg-amber-500');
            ui.btnStart.classList.add('bg-blue-600', 'hover:bg-blue-500');
            
            // Inputs entsperren
            ui.height.disabled = false;
            ui.velocity.disabled = false;
            
            updateStats();
            draw();
            calculatePredictions();
            updateIcons();
        }

        // Event Listeners
        ui.height.addEventListener('input', updateParams);
        ui.velocity.addEventListener('input', updateParams);
        
        ui.slowMo.addEventListener('change', (e) => {
            state.slowMo = e.target.checked;
        });

        ui.btnStart.addEventListener('click', toggleSimulation);
        ui.btnReset.addEventListener('click', resetSimulation);

        // Styling für Checkbox
        const style = document.createElement('style');
        style.innerHTML = `
            #slowmo:checked { right: 0; border-color: #3b82f6; }
            #slowmo:checked + .toggle-label { background-color: #3b82f6; }
        `;
        document.head.appendChild(style);

        // Init
        resizeCanvas();
        updateParams();
        resetSimulation(); // Setzt Anfangszustand

    </script>
</body>
</html>
