<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Verkehrsstau â€“ Abstandsgesteuertes Beschleunigen</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #eee;
        text-align: center;
    }
    canvas {
        background: #2b2b2b;
        display: block;
        margin: 20px auto;
        border: 2px solid #444;
    }
    .controls {
        margin: 10px;
    }
</style>
</head>
<body>

<h2>Verkehrsstau â€“ Beschleunigung nur bei Abstand</h2>

<div class="controls">
    <button onclick="triggerFrontBrake()">ðŸš¨ Vorderes Auto bremst</button>
    <button onclick="resetSimulation()">ðŸ”„ Reset</button>
    <br><br>

    Reaktionszeit:
    <input type="range" min="0" max="3" step="0.1" value="1" id="reactionSlider">
    <span id="reactionValue">1.0</span> s
    <br><br>

    Bremsdauer (alle Autos):
    <input type="range" min="0.5" max="5" step="0.5" value="2" id="brakeDurationSlider">
    <span id="brakeDurationValue">2.0</span> s
</div>

<canvas id="canvas" width="900" height="200"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const reactionSlider = document.getElementById("reactionSlider");
const reactionValue = document.getElementById("reactionValue");
const brakeDurationSlider = document.getElementById("brakeDurationSlider");
const brakeDurationValue = document.getElementById("brakeDurationValue");

reactionSlider.oninput = () => reactionValue.textContent = reactionSlider.value;
brakeDurationSlider.oninput = () => brakeDurationValue.textContent = brakeDurationSlider.value;

// ---------------- Parameter ----------------
const roadY = 100;
const carCount = 10;
const carLength = 40;
const carWidth = 20;
const pixelPerMeter = 5;

const cruiseSpeed = 100 / 3.6;
const brakeDeceleration = 7;
const acceleration = 2;

const minGapToAccelerate = 10; // Meter

// ---------------- Global ----------------
let brakeEventStarted = false;

// ---------------- Car ----------------
class Car {
    constructor(x, isLeader = false) {
        this.startX = x;
        this.isLeader = isLeader;
        this.reset();
    }

    reset() {
        this.x = this.startX;
        this.speed = cruiseSpeed;
        this.braking = false;
        this.crashed = false;

        this.brakeStartTime = null;
        this.reactToBrakeTime = null;
    }

    update(dt, time, frontCar) {
        if (this.crashed) return;

        // -------- BremsauslÃ¶sung --------
        if (this.isLeader) {
            if (this.braking && this.brakeStartTime === null) {
                this.brakeStartTime = time;
            }
        } else if (frontCar) {
            if (frontCar.brakeStartTime !== null && this.reactToBrakeTime === null) {
                this.reactToBrakeTime = frontCar.brakeStartTime;
            }

            if (
                this.reactToBrakeTime !== null &&
                time - this.reactToBrakeTime >= reactionSlider.value
            ) {
                this.braking = true;
                if (this.brakeStartTime === null) {
                    this.brakeStartTime = time;
                }
            }
        }

        // -------- Bremsphase --------
        if (this.braking) {
            this.speed -= brakeDeceleration * dt;
            if (this.speed < 0) this.speed = 0;

            if (time - this.brakeStartTime >= brakeDurationSlider.value) {
                this.braking = false;
                this.brakeStartTime = null;
            }
        }

        // -------- Abstand prÃ¼fen --------
        let gapMeters = Infinity;
        if (frontCar) {
            gapMeters = (frontCar.x - this.x - carLength) / pixelPerMeter;
        }

        // -------- Beschleunigen NUR bei Abstand --------
        if (!this.braking && this.speed < cruiseSpeed && gapMeters > minGapToAccelerate) {
            this.speed += acceleration * dt;
            if (this.speed > cruiseSpeed) this.speed = cruiseSpeed;
        }

        // -------- Crash verhindern --------
        if (frontCar) {
            const gapPx = frontCar.x - this.x - carLength;
            if (gapPx <= 0 && !this.crashed) {
                this.crashed = true;
                this.speed = 0;
                frontCar.crashed = true;
            }
        }

        // -------- Bewegung --------
        this.x += this.speed * dt * pixelPerMeter;

        // -------- RundstraÃŸe nur VOR Bremsereignis --------
        if (!brakeEventStarted && this.x > canvas.width) {
            this.x = -carLength;
        }
    }

    draw() {
        if (this.crashed) ctx.fillStyle = "#ff9933";
        else if (this.braking) ctx.fillStyle = "#ff6666";
        else ctx.fillStyle = "#66ccff";

        ctx.fillRect(this.x, roadY - carWidth / 2, carLength, carWidth);
    }
}

// ---------------- Setup ----------------
let cars = [];

function initCars() {
    brakeEventStarted = false;
    cars = [];
    for (let i = 0; i < carCount; i++) {
        cars.push(new Car(100 - i * 80, i === 0));
    }
}

initCars();

// ---------------- Controls ----------------
function triggerFrontBrake() {
    brakeEventStarted = true;
    cars[0].braking = true;
}

function resetSimulation() {
    initCars();
}

// ---------------- Loop ----------------
let lastTime = null;

function animate(time) {
    if (!lastTime) lastTime = time;
    const dt = (time - lastTime) / 1000;
    lastTime = time;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // StraÃŸe
    ctx.strokeStyle = "white";
    ctx.setLineDash([20, 10]);
    ctx.beginPath();
    ctx.moveTo(0, roadY);
    ctx.lineTo(canvas.width, roadY);
    ctx.stroke();
    ctx.setLineDash([]);

    cars.forEach((car, i) => {
        const frontCar = i === 0 ? null : cars[i - 1];
        car.update(dt, time / 1000, frontCar);
        car.draw();
    });

    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>

</body>
</html>
